import logging
import random
from collections.abc import Callable, Iterable
from pathlib import Path
from typing import Any

import matplotlib.pyplot as plt
import numpy as np
from scipy.optimize import bisect
from tqdm import tqdm

# logging setup
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)


def approximate_attractor(
    ifs: list[Callable[[tuple[float, ...]], tuple[float, ...]]],
    points: list[tuple[float, ...]],
    number_iterations: int,
) -> list[tuple[float, ...]]:
    """
    Approximates the attractor of an Iterated Function System.

    It does so by recursively applying all combinations of functions for a fixed number of iterations.

    Args:
        ifs (List[Retraction]): A list of retractions representing the functions in the IFS.
        points (List[Tuple[float, ...]]): A list of starting points in the space where
            the IFS is defined.
        number_iterations (int): The number of function applications (depth) for each sample,
            determining how far the initial point is iterated through the IFS.

    Returns:
        List[Tuple[float, ...]]: A list of points approximating the attractor after applying
            all combinations of IFS functions for the specified number of iterations.

    """
    if number_iterations == 0:
        return points

    new_points: list[tuple[float, ...]] = []
    for point in points:
        for func in ifs:
            new_points.append(func(*point))  # type: ignore[arg-type]  # noqa: PERF401

    return approximate_attractor(ifs, new_points, number_iterations - 1)


def apply_sequence(
    funcs: list[Callable[[float, Any], tuple[float, ...]]],
    point: tuple[float, ...],
) -> tuple[float, ...]:
    """
    Apply iteratively a sequence of functions to a point.

    Args:
        funcs (list[Callable[[float, Any], tuple[float, ...]]]): Functions
        point (tuple[float, ...]): Point to which the functions should be applied

    Returns:
        tuple[float, ...]: Result of f_1(f_2(...f_n(p)))

    """
    for func in funcs:
        point = func(*point)

    return point


def approximate_attractor_randomized(
    functions: list[Callable[..., tuple[float, ...]]],
    initial_points: list[tuple[float, ...]],
    number_of_samples: int,
    number_of_iterations: int,
) -> list[tuple[float, ...]]:
    """
    Approximate the attractor of an Iterated Function System (IFS) using random iteration.

    This function simulates the attractor of a given IFS by repeatedly applying randomly
    selected functions from the system to a set of initial points. For each initial point,
    a number of samples are generated by applying a random sequence of functions for a
    specified number of iterations.

    Args:
        functions (List[Callable[..., Tuple[float, ...]]]): A list of retractions representing
            the functions in the IFS.
        initial_points (List[Tuple[float, ...]]): A list of starting points in the space where
            the IFS is defined.
        number_of_samples (int): The total number of sample points to generate in the attractor.
        number_of_iterations (int): The number of function applications (depth) for each sample,
            determining how far the initial point is iterated through the IFS.

    Returns:
        list[tuple[float, ...]]: A list of points approximating the attractor after applying
            all combinations of IFS functions for the specified number of iterations.

    """
    result: list[tuple[float, ...]] = []

    for point in initial_points:
        for _ in tqdm(
            range(int(number_of_samples / len(initial_points))),
            desc=f"Approximate attractor point for initial point {point}",
        ):
            # Randomly choose a sequence of functions
            sequence = [random.choice(functions) for _ in range(number_of_iterations)]

            final_point = apply_sequence(sequence, point)
            result.append(final_point)

    return result


def _approximate_dimension_for_similarity(ifs: Iterable[np.ndarray]) -> float:
    """
    Calculate the dimension of an iterated function system of similarity transformations.

    Args:
        ifs (Iterable(np.ndarray)): Iterated function system.

    Returns:
        float: Dimension of the attractor. In the case of similarity transformation,
            the Hausdorff-dim and box-counting-dim coincide.

    """

    # Check if matrix are similarity
    def is_similarity(A: np.ndarray, tol: float = 1e-8) -> bool:
        M = A.T @ A
        eigvals = np.linalg.eigvalsh(M)
        return np.allclose(eigvals, eigvals[0], atol=tol)

    r_values = []
    for A in ifs:
        if not is_similarity(A):
            msg = "Not all matrices are similarity transformations."
            raise ValueError(msg)
        # Since A^T A = r^2 I, r = sqrt(eigenvalue)
        eigval = np.linalg.eigvalsh(A.T @ A)[0]  # they are all equal
        r = np.sqrt(eigval)
        r_values.append(r)

    def dimension_equation(s: float) -> float:
        return sum(r**s for r in r_values) - 1

    # Compute upper bound for the r_i: log(n) / log(1 / r_min)
    # this works, since dimension_equation is strictly monotonic decreasing
    # In fact we can chose s > log(n)/log(1/r_min)
    r_min = min(r_values)
    upper_bound = np.log(len(r_values)) / np.log(1 / r_min) + 1  # safety margin

    # Solve dimension_equation == 0 using bisection in interval [0, upper_bound]
    return bisect(dimension_equation, 0.0, upper_bound)


def box_count(points: np.ndarray, eps: float) -> int:
    """
    Approximates number of boxes needed for covering the points with sets of diam eps.

    Args:
        points (np.ndarray): ndarray of shape (sample_size, d), providing the
            points row by row
        eps (float): Diameter of sets to cover the points with.

    """
    boxes = set()
    # scales the boxis to unit length
    scaled = np.floor(points / eps)

    for coord in scaled:
        boxes.add(tuple(coord))
    return len(boxes)


def estimate_box_dimension(points: np.ndarray, min_exp: int = 3, max_exp: int = 10) -> float:
    """
    Estimate the box-counting dimension of a point cloud.

    It calculates a log-log linear regression on box counts.
    This function overlays grids of side length ε = 2^-k for k in the range
    [min_exp, max_exp], counts how many boxes contain at least one point,
    and fits a linear model to log(N(ε)) vs. log(1/ε). The slope of the line
    approximates the box-counting (Minkowski) dimension.

    Args:
        points: A NumPy array of shape (n_points, d) containing the sampled
            point cloud, where each row is a d-dimensional point.
        min_exp: The minimum exponent k to use for ε = 2^-k.
        max_exp: The maximum exponent k to use for ε = 2^-k.

    Returns:
        A float representing the estimated box-counting dimension.

    """
    epsilons = [2**-k for k in range(min_exp, max_exp + 1)]
    counts = [box_count(points, eps) for eps in tqdm(epsilons, desc="Computing box counts")]

    log_eps = np.log(1 / np.array(epsilons))
    log_N = np.log(counts)

    # Since N(ε) ≈ ε^(-d), use least-squares linear regression for following equation:
    # logN(ε) ≈ -d⋅logε+C = -d⋅log(1/ε)+C
    d, _ = np.polyfit(log_eps, log_N, 1)
    return d


if __name__ == "__main__":
    # Generate the attractor points with higher resolution and more samples
    number_of_samples = int(1e6)
    number_of_iterations = 20

    iterated_function_system: dict[str, list[Callable[..., tuple[float, ...]]]] = {
        "ex_functions": [
            lambda x, y: (0.8 * x + 0.1, 0.8 * y + 0.04),
            lambda x, y: (0.6 * x + 0.19, 0.6 * y + 0.5),
            lambda x, y: (0.446 * (x - y) + 0.266, 0.466 * (x + y) + 0.067),
            lambda x, y: (0.446 * (x + y) + 0.456, 0.446 * (x - y) + 0.434),
        ],
        "Sierpinski Triangle": [
            lambda x, y: (0.5 * (x - 3), 0.5 * y),
            lambda x, y: (0.5 * (x + 3), 0.5 * y),
            lambda x, y: (0.5 * x, 0.5 * (y + 3)),
        ],
        "Black Spleenwort Fern": [
            lambda _, y: (0, 0.16 * y),
            lambda x, y: (0.85 * x + 0.04 * y, -0.04 * x + 0.85 * y + 1.6),
            lambda x, y: (0.2 * x - 0.26 * y, 0.24 * x + 0.22 * y + 1.6),
            lambda x, y: (-0.15 * x + 0.28 * y, 0.26 * x + 0.24 * y + 0.44),
        ],
    }

    for name, func in iterated_function_system.items():
        logger.info("Calculating attractor for %s.", name)
        high_res_samples = approximate_attractor_randomized(
            func,
            [(1.0, 1.0)],
            number_of_samples=number_of_samples,
            number_of_iterations=number_of_iterations,
        )
        points = np.array(high_res_samples)

        logger.info("Estimating Box dimension for %s...", name)
        dimension = estimate_box_dimension(points)
        logger.info("Estimated Box dimension for %s = %s", name, dimension)

        epsilon = float(number_of_samples) ** (-1 / dimension)
        logger.info("Suggested diameter for covering sets is %d", epsilon)

        # Plot the high-resolution results
        logger.info("Creating plot for %s.", name)
        x_vals_hr, y_vals_hr = zip(*high_res_samples, strict=False)
        plt.figure(figsize=(10, 10))
        plt.scatter(x_vals_hr, y_vals_hr, s=epsilon, color="black")
        plt.axis("equal")
        plt.axis("off")
        plt.title(
            f"High-Resolution Approximation of {name} with {number_of_samples} samples \
            and {number_of_iterations} Iterations",
        )

        if not Path("./attractors").exists():
            Path("./attractors").mkdir()
        path_name = name.replace(" ", "_")
        plt.savefig(
            f"./output/attractors/{path_name}_{number_of_samples}_samples_{number_of_iterations}_iterations.jpg",
            dpi=300,
        )
        plt.close()
